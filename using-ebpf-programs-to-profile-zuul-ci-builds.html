<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Using eBPF programs to profile Zuul CI builds - Software Factory</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="./using-ebpf-programs-to-profile-zuul-ci-builds.html">

        <meta name="author" content="tristanC" />
        <meta name="description" content="This article introduces a new role named ci-tracer which leverages BPF technology to profile Zuul CI jobs and gain new insights over builds&#39; performance. The Extended Berkeley Packet Filter The BPF virtual machine is a general purpose RISC instruction set that can interpret custom programs which are loaded from the …" />

        <meta property="og:site_name" content="Software Factory" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Using eBPF programs to profile Zuul CI builds"/>
        <meta property="og:url" content="./using-ebpf-programs-to-profile-zuul-ci-builds.html"/>
        <meta property="og:description" content="This article introduces a new role named ci-tracer which leverages BPF technology to profile Zuul CI jobs and gain new insights over builds&#39; performance. The Extended Berkeley Packet Filter The BPF virtual machine is a general purpose RISC instruction set that can interpret custom programs which are loaded from the …"/>
        <meta property="article:published_time" content="2019-11-07" />
            <meta property="article:section" content="blog" />
            <meta property="article:author" content="tristanC" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css"/>
    <link href="./theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="./theme/css/pygments/solarizedlight.css" rel="stylesheet">
        <link href="./theme/css/html4css1.css" rel="stylesheet">
    <link rel="stylesheet" href="./theme/css/style.css" type="text/css"/>


        <link href="./blog.xml" type="application/atom+xml" rel="alternate"
              title="Software Factory blog ATOM Feed"/>
</head>
<body>

<div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="./" class="navbar-brand">
<img class="img-responsive pull-left gap-right" src="./images/SoftwareFactory-logo.svg" width="20px"/> Software Factory            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                         <li><a href="./pages/contact.html">
                             Contact
                          </a></li>
                        <li class="active">
                            <a href="./category/blog.html">Blog</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="./using-ebpf-programs-to-profile-zuul-ci-builds.html"
                       rel="bookmark"
                       title="Permalink to Using eBPF programs to profile Zuul CI builds">
                        Using eBPF programs to profile Zuul CI builds
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2019-11-07T00:00:00+00:00"> Thu 07 November 2019</time>
    </span>


            <span class="label label-default">By</span>
            <a href="./author/tristanc.html"><i class="fa fa-user"></i> tristanC</a>



    
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>This article introduces a new role named <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/">ci-tracer</a> which leverages BPF technology
to profile <a class="reference external" href="https://zuul-ci.org/">Zuul CI</a> jobs and gain new insights over builds' performance.</p>
<div class="section" id="the-extended-berkeley-packet-filter">
<h2>The Extended Berkeley Packet Filter</h2>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">BPF</a> virtual machine is a general purpose RISC instruction set that
can interpret custom programs which are loaded from the user space.
While it was originally designed for network packet processing,
the Linux kernel implements an extended version, named <a class="reference external" href="https://www.kernel.org/doc/html/latest/bpf/">eBPF</a>, that can be
used to safely attach programs to various tracepoints and inspect kernel data structures.
If you are running a modern Linux system, chances are you already use BPF programs:</p>
<div class="highlight"><pre><span></span><span class="c1"># List running BPF programs</span>
$ sudo ls -l /proc/*/fd <span class="p">|</span> grep bpf
</pre></div>
<p>For the purpose of this article we are only going to use the <strong>TRACEPOINT</strong> and <strong>KPROBE</strong> types of programs.
Other types of programs are currently being used for all sorts of things, such as, the new
CgroupV2 which implements an eBPF based device controller.</p>
<p>While the BPF bytecode can be written by hand and loaded manually, we are going to use the <a class="reference external" href="https://github.com/iovisor/bcc">BCC</a>
toolkit to implement the <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/">ci-tracer</a> role.</p>
</div>
<div class="section" id="bcc-bpf-compiler-and-python-frontend">
<h2>BCC: BPF Compiler And Python Frontend</h2>
<p>The <a class="reference external" href="https://github.com/iovisor/bcc">BCC</a> project provides an easy to use toolkit to load BPF programs using
Python and a C wrapper around LLVM. It comes with ready-to-use examples to get started,
for example, <a class="reference external" href="https://github.com/iovisor/bcc/blob/master/tools/cpudist.py">cpudist</a> can show the cpu time distribution of every processes running on a system:</p>
<div class="highlight"><pre><span></span>$ sudo /usr/share/bcc/tools/cpudist -P <span class="m">5</span>
Tracing on-CPU time... Hit Ctrl-C to end.

<span class="nv">pid</span> <span class="o">=</span> <span class="m">271090</span> emacs

  usecs               : count     distribution
      <span class="m">0</span> -&gt; <span class="m">1</span>          : <span class="m">0</span>        <span class="p">|</span>                                        <span class="p">|</span>
      <span class="m">2</span> -&gt; <span class="m">3</span>          : <span class="m">0</span>        <span class="p">|</span>                                        <span class="p">|</span>
      <span class="m">4</span> -&gt; <span class="m">7</span>          : <span class="m">0</span>        <span class="p">|</span>                                        <span class="p">|</span>
      <span class="m">8</span> -&gt; <span class="m">15</span>         : <span class="m">0</span>        <span class="p">|</span>                                        <span class="p">|</span>
     <span class="m">16</span> -&gt; <span class="m">31</span>         : <span class="m">1</span>        <span class="p">|</span>********************                    <span class="p">|</span>
     <span class="m">32</span> -&gt; <span class="m">63</span>         : <span class="m">0</span>        <span class="p">|</span>                                        <span class="p">|</span>
     <span class="m">64</span> -&gt; <span class="m">127</span>        : <span class="m">2</span>        <span class="p">|</span>****************************************<span class="p">|</span>
    <span class="m">128</span> -&gt; <span class="m">255</span>        : <span class="m">2</span>        <span class="p">|</span>****************************************<span class="p">|</span>
    <span class="m">256</span> -&gt; <span class="m">511</span>        : <span class="m">1</span>        <span class="p">|</span>********************                    <span class="p">|</span>
    <span class="m">512</span> -&gt; <span class="m">1023</span>       : <span class="m">0</span>        <span class="p">|</span>                                        <span class="p">|</span>
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
<p>This <a class="reference external" href="https://github.com/iovisor/bcc/blob/master/tools/cpudist.py">cpudist</a> tool works by attaching a kprobe program to the <em>finish_task_switch</em>
function that gets evaluated each time the kernel switches tasks on a CPU.
The BPF program does the following:</p>
<ul class="simple">
<li>Record the start time of the next task.</li>
<li>If it knows when the previous task started, it records how long the task spent on CPU.</li>
</ul>
<p>The Python code only prints the recorded value periodically.</p>
<p>This is a very efficient process, as the intensive work is running inside the BPF virtual
machine which can interpret the program frequently with minimal overhead. Indeed such a low-level
<em>finish_task_switch</em> kprobe can be triggered millions of times per second on a busy system.</p>
<p>The <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/">ci-tracer</a> implements a custom BPF program to collect fine grained information from <a class="reference external" href="https://zuul-ci.org/">Zuul CI</a>
builds.</p>
</div>
<div class="section" id="introducing-ci-tracer">
<h2>Introducing ci-tracer</h2>
<p>A <a class="reference external" href="https://zuul-ci.org/">Zuul CI</a> build is composed of Ansible tasks that execute processes on ephemeral test instances.
The <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/">ci-tracer</a> is designed to load a custom BPF program in the test instance to gather information
about the processes. This initial implementation collects on-CPU times which this article will discuss
further in the conclusion.</p>
<p>The implementation is composed of two components:</p>
<ul class="simple">
<li>a BPF program <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/src/agent.c">agent.c</a>, and</li>
<li>a Python service <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/src/agent.py">agent.py</a>.</li>
</ul>
<p>Let's look at the BPF Program.</p>
<div class="section" id="the-bpf-program">
<h3>The BPF Program</h3>
<p>From the kernel point of view, the unit of computing is a <em>task</em> that is represented by a <em>task_struct</em>.
A task (also called thread) is assigned an identifier named <em>pid</em> and multiple tasks can be grouped by a <em>tgid</em>.
Note that this differs from the user point of view where a <em>pid</em> is actually a <em>tgid</em>...
This is confusing when going back and forth between userland and kernelland, thus we will name:</p>
<ul class="simple">
<li>A process is an userland <em>pid</em>, kernelland <em>tgid</em>.</li>
<li>A task (or thread) is an userland <em>tid</em>, kernelland <em>pid</em>.</li>
</ul>
<p>This initial implementation doesn't collect individual task.
Instead the measurements are grouped by <em>tgid</em>.</p>
<div class="section" id="on-cpu-measure">
<h4>On-CPU Measure</h4>
<p>Two data structures are used to measure the time each process spent on-cpu:</p>
<div class="highlight"><pre><span></span><span class="c1">// Internal data to record next task start time</span>
<span class="n">BPF_HASH</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="p">,</span><span class="w"> </span><span class="n">PID_MAX</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Shared data of tgid and oncpu time</span>
<span class="n">BPF_HASH</span><span class="p">(</span><span class="n">oncpus</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="p">,</span><span class="w"> </span><span class="n">PID_MAX</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Then the <em>finish_task_switch</em> probe does the following:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">finish_task_switch</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pt_regs</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// At this time, prev is not running, next is going to be scheduled</span>
<span class="w">  </span><span class="n">u64</span><span class="w"> </span><span class="n">cur_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_ktime_get_ns</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">tgid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tgid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="o">*</span><span class="n">prev_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_time</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev_time</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Previous task start time was recorded, compute the time it spent oncpu</span>
<span class="w">      </span><span class="n">u64</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cur_time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">prev_time</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">delta</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">INTERVAL_NS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Per tgid cpu info</span>
<span class="w">        </span><span class="n">u64</span><span class="w"> </span><span class="o">*</span><span class="n">oncpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oncpus</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tgid</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">oncpu</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">delta</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">oncpu</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Record time per task group</span>
<span class="w">        </span><span class="n">oncpus</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tgid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">delta</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Record the start time of the next task</span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">next_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_get_current_pid_tgid</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cur_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_ktime_get_ns</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">start_time</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_pid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cur_time</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This program updates the <em>oncpus</em> hash table with the processes (userland pid) as key and
the cpu times in nanoseconds as value.</p>
<p>By the time the Python service reads the <em>oncpus</em> hash table, the process may have died.
Thus, we use another probe to record the processes information.</p>
</div>
<div class="section" id="execution-event">
<h4>Execution Event</h4>
<p>As demonstrated by the BCC <a class="reference external" href="https://github.com/iovisor/bcc/blob/master/tools/execsnoop.py">execsnoop</a> tool, we can get new processes information, with a <em>perf</em> channel:</p>
<div class="highlight"><pre><span></span><span class="c1">// The exec perf channel</span>
<span class="n">BPF_PERF_OUTPUT</span><span class="p">(</span><span class="n">execs</span><span class="p">);</span><span class="w"></span>

<span class="c1">// The type of event sent back to userland</span>
<span class="k">enum</span><span class="w"> </span><span class="n">execs_perf_type</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">EVENT_TYPE_INIT</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">EVENT_TYPE_ARGS</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">EVENT_TYPE_EXEC</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">EVENT_TYPE_EXIT</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">EVENT_TYPE_FORK</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// The event structure</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">exec_info_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">execs_perf_type</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">ppid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">u32</span><span class="w"> </span><span class="n">cgroup</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">arg</span><span class="p">[</span><span class="n">ARGSIZE</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>Then we attach multiple probes and tracepoints on the different process lifecycle steps:</p>
<ul class="simple">
<li>KPROBE on the clone syscall: when a thread is created (unused at the moment).</li>
<li>TRACEPOINT_PROBE(sched, sched_process_fork): when a process forks.</li>
<li>KPROBE on the execve syscall: when a process executes a command.</li>
<li>KPROBE on the execve ret syscall: when a process succeeds in executing a command.</li>
<li>TRACEPOINT_PROBE(sched, sched_process_exit): when a process exits.</li>
</ul>
<p>Each probe can send process information through the <em>execs</em> perf channel created earlier,
for example, when a process forks:</p>
<div class="highlight"><pre><span></span><span class="n">TRACEPOINT_PROBE</span><span class="p">(</span><span class="n">sched</span><span class="p">,</span><span class="w"> </span><span class="n">sched_process_fork</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">exec_info_t</span><span class="w"> </span><span class="n">inf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">  </span><span class="n">inf</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EVENT_TYPE_FORK</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">inf</span><span class="p">.</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="o">-&gt;</span><span class="n">child_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">inf</span><span class="p">.</span><span class="n">ppid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="o">-&gt;</span><span class="n">parent_pid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">inf</span><span class="p">.</span><span class="n">cgroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bpf_get_current_cgroup_id</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">execs</span><span class="p">.</span><span class="n">perf_submit</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">inf</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Check out the <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/src/agent.c">agent.c</a> source code to see how the other execve probes are implemented.</p>
<p>The <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/">ci-tracer</a> BPF program collects process lifecycle events and the time they spend on-cpu.
Next let's look at the Python service.</p>
</div>
</div>
<div class="section" id="the-python-service">
<h3>The Python Service</h3>
<p>The purpose of the Python service <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/src/agent.py">agent.py</a> is to process the information collected by the
BPF program. It is composed of two parts:</p>
<ul class="simple">
<li>a callback for the <em>execs</em> perf event, and</li>
<li>a main loop to read the <em>oncpus</em> measures.</li>
</ul>
<p>Its goal is to serialize the measurements so that they can be analyzed after the build is completed.</p>
<div class="section" id="bpf-to-userland">
<h4>BPF To Userland</h4>
<p>The callback is executed each time an <em>execs</em> perf event occurs, and it keeps track
of the processes information in a dictionary like so:</p>
<div class="highlight"><pre><span></span><span class="c1"># Cache pid info</span>
<span class="n">pids</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Process</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">handle_exec_event</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Process execs perf event&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">EventType</span><span class="o">.</span><span class="n">FORK</span><span class="p">:</span>
            <span class="c1"># Copy the parent process info</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">pids</span><span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">ppid</span><span class="p">]</span>
            <span class="n">pid</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">ppid</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">cid</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
            <span class="n">pid</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
            <span class="n">pids</span><span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid</span>

        <span class="o">...</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># Sometime pids are unknown when process clone or events are out of order.</span>
        <span class="c1"># It&#39;s ok, we only care about pids that successfully execve.</span>
        <span class="c1"># warn(f&quot;Unknown {event.pid} {event.ppid} for {event.type} ({event.arg})&quot;)</span>
        <span class="k">pass</span>


<span class="n">bpf</span><span class="o">.</span><span class="n">attach_kprobe</span><span class="p">(</span><span class="n">event</span><span class="o">=</span><span class="n">bpf</span><span class="o">.</span><span class="n">get_syscall_fnname</span><span class="p">(</span><span class="s2">&quot;execve&quot;</span><span class="p">),</span> <span class="n">fn_name</span><span class="o">=</span><span class="s2">&quot;syscall__execve&quot;</span><span class="p">)</span>
<span class="n">bpf</span><span class="o">.</span><span class="n">attach_kretprobe</span><span class="p">(</span><span class="n">event</span><span class="o">=</span><span class="n">bpf</span><span class="o">.</span><span class="n">get_syscall_fnname</span><span class="p">(</span><span class="s2">&quot;execve&quot;</span><span class="p">),</span> <span class="n">fn_name</span><span class="o">=</span><span class="s2">&quot;do_ret_sys_execve&quot;</span><span class="p">)</span>
<span class="n">bpf</span><span class="p">[</span><span class="s2">&quot;execs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">open_perf_buffer</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">handle_exec_event</span><span class="p">(</span><span class="n">bpf</span><span class="p">[</span><span class="s2">&quot;execs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span>
</pre></div>
<p>Then main loop is in charge of collecting the <em>oncpus</em> measures and it generates the
report periodically:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">collect_cpu</span><span class="p">(</span><span class="n">oncpus</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Perf</span><span class="p">,</span> <span class="n">Perf</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Periodically dump the oncpus content&quot;&quot;&quot;</span>
    <span class="n">cpu_start</span> <span class="o">=</span> <span class="n">monotonic</span><span class="p">()</span>
    <span class="n">interval_sec</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">interval</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="c1"># Clock based sleep to take into account the serialization time below</span>
        <span class="n">clock_time</span> <span class="o">=</span> <span class="n">interval_sec</span> <span class="o">-</span> <span class="p">(</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">cpu_start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clock_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sleep</span><span class="p">(</span><span class="n">clock_time</span><span class="p">)</span>
        <span class="n">cpu_start</span> <span class="o">=</span> <span class="n">monotonic</span><span class="p">()</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Fast loop to extract oncpus measures</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">oncpus</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ts</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">value</span>  <span class="o">/</span> <span class="mf">1e6</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">min_cpu</span> <span class="ow">and</span> <span class="n">ts</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">min_cpu</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">pid</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="n">pid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pids</span><span class="p">:</span>
                <span class="c1"># Skip unknown pids</span>
                <span class="k">continue</span>
            <span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pid</span><span class="p">,</span> <span class="n">ts</span><span class="p">))</span>
        <span class="n">oncpus</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># Serialize events</span>
        <span class="n">relnow</span> <span class="o">=</span> <span class="n">cpu_start</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="n">tl</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;{&quot;ts&quot;: </span><span class="si">%.2f</span><span class="s1">},&#39;</span> <span class="o">%</span> <span class="n">relnow</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pid</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
            <span class="n">inf</span> <span class="o">=</span> <span class="n">pids</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">inf</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">relnow</span> <span class="o">-</span> <span class="n">inf</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">.5</span><span class="p">:</span>
                <span class="c1"># Process started less than .5 second ago</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">pid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pids_serialized</span><span class="p">:</span>
                <span class="c1"># Put the pid informations in the report</span>
                <span class="n">inf</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
                <span class="n">pids_serialized</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
            <span class="n">tl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;{&quot;cpu&quot;: </span><span class="si">%d</span><span class="s1">, &quot;v&quot;: </span><span class="si">%.3f</span><span class="s1">},&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">ts</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tl</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

<span class="n">bpf</span><span class="o">.</span><span class="n">attach_kprobe</span><span class="p">(</span><span class="n">event</span><span class="o">=</span><span class="s2">&quot;finish_task_switch&quot;</span><span class="p">,</span> <span class="n">fn_name</span><span class="o">=</span><span class="s2">&quot;finish_task_switch&quot;</span><span class="p">)</span>
<span class="n">collect_cpu</span><span class="p">(</span><span class="n">bpf</span><span class="p">[</span><span class="s2">&quot;oncpus&quot;</span><span class="p">])</span>
</pre></div>
<p>The goal is to prevent overwhelming the report and have a low signal-to-noise ratio
while achieving a minimal overhead.</p>
</div>
<div class="section" id="the-report-format">
<h4>The Report Format</h4>
<p>The service produces a stream of JSON objects:</p>
<ul class="simple">
<li>When a new process is measured, its information such as start time,
command line arguments, cgroups, and parents are serialized like so:</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">&quot;cgr&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2624</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;v&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;user.slice/user-1000.slice/session-55.scope&quot;</span><span class="p">},</span><span class="w"></span>
<span class="p">{</span><span class="nt">&quot;pid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5144</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;ppid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5105</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;t&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">110</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;cg&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2624</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;v&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;/bin/sh&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;-c&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;/usr/bin/python3 &amp;&amp; sleep 0&quot;</span><span class="p">]},</span><span class="w"></span>
<span class="p">{</span><span class="nt">&quot;pid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5173</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;ppid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5144</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;t&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">110</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;cg&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2624</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;v&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;/usr/bin/python3&quot;</span><span class="p">]},</span><span class="w"></span>
<span class="p">{</span><span class="nt">&quot;pid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5278</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;ppid&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5173</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;t&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">110</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;cg&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2624</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;v&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;/usr/bin/tox&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;-e&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;py37&quot;</span><span class="p">]},</span><span class="w"></span>
</pre></div>
<ul class="simple">
<li>Then periodically, the <em>oncpus</em> measures are dumped like so:</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">&quot;ts&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">111.16</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;cpu&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5173</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;v&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">41.357</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;cpu&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">5278</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;v&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">169.483</span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>To save space, all the timestamps are relative to the start time and the measures are in milliseconds.
With such reports, we can now build a visualization:</p>
</div>
</div>
<div class="section" id="the-data-driven-document-d3js-report">
<h3>The Data Driven Document (D3js) Report</h3>
<p>The current report interface looks like this:</p>
<img alt="None" src="images/ci-tracer-2019-11.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The time serie data points are grouped into a list of processes sorted by total CPU time
and represented as a heatmap.
The <a class="reference external" href="https://d3js.org">D3js</a> library provides an efficient framework to render large datasets as it lets
us display each data point without normalizing the data:</p>
<div class="highlight"><pre><span></span><span class="c1">// dates is a list of Date object created for each &quot;ts&quot; event</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">d3</span><span class="p">.</span><span class="nx">scaleBand</span><span class="p">().</span><span class="nx">range</span><span class="p">([</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">height</span><span class="p">]).</span><span class="nx">domain</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">d</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">pid</span><span class="p">))).</span><span class="nx">padding</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">d3</span><span class="p">.</span><span class="nx">scaleUtc</span><span class="p">().</span><span class="nx">range</span><span class="p">([</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">width</span><span class="p">]).</span><span class="nx">domain</span><span class="p">([</span><span class="nx">startDate</span><span class="p">,</span><span class="w"> </span><span class="nx">endDate</span><span class="p">]),</span><span class="w"></span>

<span class="cm">/* axis labels, notes, ... */</span><span class="w"></span>

<span class="c1">// Each row is a group</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">svg</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.row&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="nx">enter</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;svg:g&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;row&#39;</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Each cpu_event result in a new cell</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">row</span><span class="p">.</span><span class="nx">selectAll</span><span class="p">(</span><span class="s1">&#39;.cell&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="nx">d</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">d</span><span class="p">.</span><span class="nx">cpu_events</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">e</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">({</span><span class="w"></span>
<span class="w">      </span><span class="nx">y</span><span class="o">:</span><span class="w"> </span><span class="nx">d</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="nx">dates</span><span class="p">[</span><span class="nx">e</span><span class="p">[</span><span class="mf">0</span><span class="p">]],</span><span class="w"> </span><span class="nx">v</span><span class="o">:</span><span class="w"> </span><span class="nx">e</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">})))</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">enter</span><span class="p">().</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;rect&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;cell&#39;</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Redraw sets objects coordinates</span><span class="w"></span>
<span class="kd">function</span><span class="w"> </span><span class="nx">redraw</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">domain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">.</span><span class="nx">domain</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="nx">bw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">((</span><span class="nx">domain</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">domain</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">1000</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">cell</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">x</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">y</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">y</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">bw</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">rowHeight</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">myColor</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">v</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">1000</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Thanks to the <em>scaleUtc</em> object it is easy to annotate the map with the Ansible task timestamps
and zoom in at particular areas of interest. Check out the code in the <a class="reference external" href="https://softwarefactory-project.io/cgit/software-factory/ci-tracer/tree/web">web directory</a>.</p>
<p>Another interesting visualization is the sunburst where pid hierarchy are displayed on a circle:</p>
<img alt="None" src="images/ci-tracer-2019-11-sunburst.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This report is from a DLRN rpm build job and it has been produced using this
<a class="reference external" href="https://softwarefactory-project.io/r/#/c/16971/">review</a> (in the job result click the <em>CiTracer report</em> link).</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>Using eBPF programs to profile CI jobs let us efficiently compile large amount of data to gain
new perspective on builds' performance.
While this initial version only collects on-CPU times, it accounts for less than 0.1% of the total job
load and it produces about 100KB of data per minute when sampling every seconds.</p>
<p>However this work is still in early development and the following are priorities:</p>
<ul class="simple">
<li>Better heatmap interface with cgroup navigation.</li>
<li>Add more kprobes or task_struct data to measure:<ul>
<li>Block devince IO,</li>
<li>Network traffic,</li>
<li>Memory pressure,</li>
<li>Syscalls count, ...</li>
</ul>
</li>
<li>Update the heatmap to split the cell for each type of measurements.</li>
<li>Improve Ansible task process collection to get the actual module name.</li>
</ul>
<p>If you would like to give this a try or get involved, please reach out by mail or on the
#softwarefactory and #zuul Freenode channels.</p>
</div>

            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Recent Posts -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Recent Posts</span></h4>
  <ul class="list-group" id="recentposts">
    <li class="list-group-item"><a href="./sprint-2024-aug-09-to-2024-aug-28-summary.html">Sprint 2024 Aug 09 to 2024 Aug 28 summary</a></li>
    <li class="list-group-item"><a href="./sprint-2024-jul-19-to-2024-aug-07-summary.html">Sprint 2024 Jul 19 to 2024 Aug 07 summary</a></li>
    <li class="list-group-item"><a href="./sprint-2024-jun-28-to-2024-jul-17-summary.html">Sprint 2024 Jun 28 to 2024 Jul 17 summary</a></li>
    <li class="list-group-item"><a href="./sprint-2024-jun-07-to-2024-jun-26-summary.html">Sprint 2024 Jun 07 to 2024 Jun 26 summary</a></li>
    <li class="list-group-item"><a href="./sprint-2024-may-16-to-2024-jun-05-summary.html">Sprint 2024 May 16 to 2024 Jun 05 summary</a></li>
  </ul>
</li>
<!-- End Sidebar/Recent Posts -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2024 Red Hat
           &middot; Powered by <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>
           &middot; This work is licensed under a
               <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
                 Creative Commons Attribution 4.0 International License
               </a>.
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="./theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="./theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="./theme/js/respond.min.js"></script>




</body>
</html>